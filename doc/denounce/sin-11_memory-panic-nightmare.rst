噩梦小插曲，内存恐慌
=====================

**from ???**

.. code-block:: c

    404 Not Found

按照 denounce 的评判标准来说，这一段其实不应该被包含进来，但是实在是憋不住了，不顺带提一嘴心里堵得慌。

miniOS 的基准代码中贴心地附上了内存模型，但殊不知这正是噩梦的始作俑者。

先贴几个补充事实：

1. 可以为链接器指定各个段的基地址
2. 静态可重定向文件各个符号的相对定位是固定的，无法或者说难以手动指定
3. 默认情况下，链接器按给出的目标文件列表的顺序进行链接操作
4. 对于每一个目标文件，链接器在对应段上顺序定位，先链接的在段的低地址处，后链接的在段的高地址处
5. 可以强制指定符号的地址，但这不会影响其余符号的重定位，若符号对应的数据区间存在重叠，可能引发不可预估的错误

好了，再回到基准代码。

在设计中，loader 被加载到物理地址 0x00090000 处，而 kernel elf 将被加载到物理地址 0x00080000 处。

内核的 text 段基址指定为 0xc0030400，在内存模型中，kernel runtime 的内存区间被编排在 0x00030000~0x00080000，也即 elf 段的安全加载区间应该在 0xc0000400~0xc0080000。

那么问题来了，kernel 的 elf 加载多少谁说了算？内存模型说了不算，elf 自己说了算。

初始的内核栈在 bss 段中定义，也即在 text 和 data 段之后。

若不做额外的处理，也即 text、data、bss 三个段是紧邻的，假定系统严格按照给出的内存模型操作，那么其稳定运行的充分条件应当是\ **内存模型正确**。

那么它正确吗？前面提到了，这事得由 elf 说了算。

loader 的起始地址附近存储了 gdt，该部分将在 kernel 中被拷贝至内核空间，到此 loader 的任务彻底结束，其内存空间可以自由用于其它用途。

而放置 kernel.bin 的区间，由于 load 段的加载地址紧密排列，所以 kernel elf 加载至内核空间时一定不存在差错。

可 loader 就不一样了，放置 kernel.bin 的内存空间被覆写也无所谓，因为加载一定是正确的，可 loader 的任务要约莫执行到 kernel_main 才算结束，在这之前对 loader 内存空间的任意非法内存写都是潜在的致命因素。

那么如果 elf 中 load 段的符号越过了 0xc0090000 会发生什么？将会与 loader 重叠！并且将直接重叠 loader 中待被拷贝的 gdt 数据段！

如果越过的是 text 或 data 段，那么 gdt 将被直接破坏。

但相对于 text 或 data 段，bss 段显然更容易越过 loader 的内存空间。并且由于产生于 resb 的 bss 段符号不清空的处理，覆写的问题将更加隐蔽。或许立即被写，或许延迟一段时间被写，又或许永远都不会被写。在后两种情形下，出现问题时调试的难度远远高于前者，等问题出现时，上下文大概往往是“貌似”与真正有问题的地方八竿子打不着。

.. note::

    loader 中将 0xc0000000 映射至物理地址 0x00000000

这时候再回过头来看看\ **补充事实的第 4 点**：地址依据链接次序顺序编排。

在原始的 Makefile 里，kernel.asm 被安排在第一个链接项，栈区被安排在此目标文件的 bss 段偏移 0 位置，也即在加载时会被加载到 kernel.bin bss 段的基址上。

现在的 kernel 并不那么大，bss 基址几乎总是可以落在 0xc0040000 附近的地方。

可如果 kernel.asm 的目标文件被最后链接呢？在 ``uniform-minios >= 0.5.1`` 的某一个版本中，内核栈顶直接干到了 0xc0090140 左右的位置，而 loader 中的 gdt 基址则是 0x90102——他们是在一个物理页面上！

这意味着什么？可能无事发生，也可能只不过是一个 call 指令把返回地址压栈，gdt 就被写了！

如果这件事在 gdt 拷贝完成之前发生，那么加载了错误的 gdt 会发生什么简直难以想象。

可能是直接反复干穿 bios，也可能只是无事发生，更可能是干穿一次 bios 后然后又无事发生地正常进入 kernel_main。

*以下省略三千字……*

这个问题好解决吗？意识到是 gdt 出问题了，那简直不要太简单，loader gdt 的地址是固定的，直接 gdb 打个 watch 分分钟就能定位覆写 gdt 的位置。可要是没有意识到，那可就真是怀疑天怀疑地怀疑空气，出错代码附近的玩意但凡沾亲带故的都得通通排查过去。

*当然如果对整个系统具有极强掌控力和极高自信心，那就算一开始没意识到 gdt 的问题也应该能第一时间排除掉大部分可能。*

截至 v0.6.0，uniform 依旧\ **暂时**\ 没有优雅的办法处理越界的问题，而是简单地强制 kernel.asm 首先被链接来先缓和下问题，凑活过过日子。

总不能，每次 kernel 大小变了我都要人力瞅一眼再到处爆改常量吧？

那可真是——既怠惰又不优雅。
