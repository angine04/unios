页表：梅开三度！我就是全场最靓的崽
===================================

**from kernel/console.c:w_copy**

.. code-block:: c

    static void w_copy(unsigned int dst, const unsigned int src, int size) {
        memcpy(
            (void*)(V_MEM_BASE + (dst << 1)),
            (void*)(V_MEM_BASE + (src << 1)),
            size << 1);
    }

简而言之，言而简之，这件事我只能说懂得都懂，不懂的呢也别趟这趟混水了，乐呵乐呵就完事了。

**前情提要：逆天页表独领风骚**

在一些名叫 **如能跑** 的神秘学代码的作用下，旧页表成功地实现了为线性地址 0 映射了物理页面。

由之前的谴责可以得知，咱的 kernel 是压根没有访问线性地址 0 的去处的，这 0 的映射要么是旧页表的错误映射，要么是 loader 阶段建立的映射没有清除——或者说， **如清除**。

于是到了 console 的实现里，就会出现这么一个匪夷所思的 BUG：在看上去十分正确的功能实现下，当 console 需要翻页时，实现分明正确拷贝翻页了，可屏幕上却偏偏会兜兜转转绕一圈将最初的第 0 行所在的那一屏重新打印出来。

莫非是在这实现的某个角落里存在极难察觉的坐标设置问题，使得它周期性翻转了？又或者干脆是没有清空显存？

不晓得，时间有限，在前期粗浅修了 tty 便没再去管这 console 了，毕竟是无伤大雅的事情。

可是在最新的页表全面重写后，一些新的蜜汁问题却又蹦了出来。关于此前文已有样例，但此处且就单单盯着这 console，来一次旧活新整。

**请，再看它一眼！**

.. code-block:: c

    static void w_copy(unsigned int dst, const unsigned int src, int size) {
        memcpy(
            (void*)(V_MEM_BASE + (dst << 1)),
            (void*)(V_MEM_BASE + (src << 1)),
            size << 1);
    }

**再来瞅瞅别个去处？**

.. code-block:: c

    static void clear_screen(int pos, int len) {
        uint8_t* pch = (uint8_t*)K_PHY2LIN(V_MEM_BASE + pos * 2);
        while (--len >= 0) {
            *pch++ = ' ';
            *pch++ = (uint8_t)DEFAULT_CHAR_COLOR;
        }
    }

*问题是什么？*

MLGB 的，这显存基址分明就不是个线性地址啊！

*那他为什么能访问呢？*

旧页表有大恐怖啊，他搁那线性地址 0 附近的地方有页表项， **恰巧** 访问不会缺页呀！

*那岂不就是说？——*

是极是极！这玩意压根写的内存就不对，只不过恰好没原地爆炸升天罢了！再看那功能实现——操作都操作到别人家里去了，没被人家打死已是踩了狗屎运，哪里还敢苛求个富贵！

w_copy？呵！ **如调用** 罢了！

不过话又说回来，将这地址转换了去，内核处的线性地址便是对吗？

确实，访存一致了，页表项正确了，功能等诸多方面也着实是无误了。

可莫要忘了这 VGA 显存的基址为 0x000b8000，如今却要教这诸多外因转换去了 0xc00b8000，如此依旧是对吗？

大抵是众口难一。

我是觉得，既然已经将这规矩打破，要么便破碎个彻底，让着基址随波逐流，莫要再赖皮着个 0x000b8000；要么就把规矩重新树立好，将这 0x000b8000 给好好映射到那一般模样的线性地址，别再整个 **吃着碗里，看着锅里** 的笑话了！
